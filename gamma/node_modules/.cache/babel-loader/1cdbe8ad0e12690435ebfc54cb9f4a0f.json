{"ast":null,"code":"import { Vector, calculateBounds, getDistances, isPointInside, randomInRange } from \"tsparticles-engine\";\nexport class OutOutMode {\n  constructor(container) {\n    this.container = container;\n    this.modes = [\"out\"];\n  }\n\n  update(particle, direction, delta, outMode) {\n    if (!this.modes.includes(outMode)) {\n      return;\n    }\n\n    const container = this.container;\n\n    switch (particle.outType) {\n      case \"inside\":\n        {\n          const {\n            x: vx,\n            y: vy\n          } = particle.velocity;\n          const circVec = Vector.origin;\n          circVec.length = particle.moveCenter.radius;\n          circVec.angle = particle.velocity.angle + Math.PI;\n          circVec.addTo(Vector.create(particle.moveCenter));\n          const {\n            dx,\n            dy\n          } = getDistances(particle.position, circVec);\n\n          if (vx <= 0 && dx >= 0 || vy <= 0 && dy >= 0 || vx >= 0 && dx <= 0 || vy >= 0 && dy <= 0) {\n            return;\n          }\n\n          particle.position.x = Math.floor(randomInRange({\n            min: 0,\n            max: container.canvas.size.width\n          }));\n          particle.position.y = Math.floor(randomInRange({\n            min: 0,\n            max: container.canvas.size.height\n          }));\n          const {\n            dx: newDx,\n            dy: newDy\n          } = getDistances(particle.position, particle.moveCenter);\n          particle.direction = Math.atan2(-newDy, -newDx);\n          particle.velocity.angle = particle.direction;\n          break;\n        }\n\n      default:\n        {\n          if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n            return;\n          }\n\n          switch (particle.outType) {\n            case \"outside\":\n              {\n                particle.position.x = Math.floor(randomInRange({\n                  min: -particle.moveCenter.radius,\n                  max: particle.moveCenter.radius\n                })) + particle.moveCenter.x;\n                particle.position.y = Math.floor(randomInRange({\n                  min: -particle.moveCenter.radius,\n                  max: particle.moveCenter.radius\n                })) + particle.moveCenter.y;\n                const {\n                  dx,\n                  dy\n                } = getDistances(particle.position, particle.moveCenter);\n\n                if (particle.moveCenter.radius) {\n                  particle.direction = Math.atan2(dy, dx);\n                  particle.velocity.angle = particle.direction;\n                }\n\n                break;\n              }\n\n            case \"normal\":\n              {\n                const wrap = particle.options.move.warp,\n                      canvasSize = container.canvas.size,\n                      newPos = {\n                  bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\n                  left: -particle.getRadius() - particle.offset.x,\n                  right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                  top: -particle.getRadius() - particle.offset.y\n                },\n                      sizeValue = particle.getRadius(),\n                      nextBounds = calculateBounds(particle.position, sizeValue);\n\n                if (direction === \"right\" && nextBounds.left > canvasSize.width + particle.offset.x) {\n                  particle.position.x = newPos.left;\n                  particle.initialPosition.x = particle.position.x;\n\n                  if (!wrap) {\n                    particle.position.y = Math.random() * canvasSize.height;\n                    particle.initialPosition.y = particle.position.y;\n                  }\n                } else if (direction === \"left\" && nextBounds.right < -particle.offset.x) {\n                  particle.position.x = newPos.right;\n                  particle.initialPosition.x = particle.position.x;\n\n                  if (!wrap) {\n                    particle.position.y = Math.random() * canvasSize.height;\n                    particle.initialPosition.y = particle.position.y;\n                  }\n                }\n\n                if (direction === \"bottom\" && nextBounds.top > canvasSize.height + particle.offset.y) {\n                  if (!wrap) {\n                    particle.position.x = Math.random() * canvasSize.width;\n                    particle.initialPosition.x = particle.position.x;\n                  }\n\n                  particle.position.y = newPos.top;\n                  particle.initialPosition.y = particle.position.y;\n                } else if (direction === \"top\" && nextBounds.bottom < -particle.offset.y) {\n                  if (!wrap) {\n                    particle.position.x = Math.random() * canvasSize.width;\n                    particle.initialPosition.x = particle.position.x;\n                  }\n\n                  particle.position.y = newPos.bottom;\n                  particle.initialPosition.y = particle.position.y;\n                }\n\n                break;\n              }\n          }\n\n          break;\n        }\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/Users/dhair_gzqoc8v/Desktop/DBMS/DBMS_Project/gamma/node_modules/tsparticles-updater-out-modes/OutOutMode.js"],"names":["Vector","calculateBounds","getDistances","isPointInside","randomInRange","OutOutMode","constructor","container","modes","update","particle","direction","delta","outMode","includes","outType","x","vx","y","vy","velocity","circVec","origin","length","moveCenter","radius","angle","Math","PI","addTo","create","dx","dy","position","floor","min","max","canvas","size","width","height","newDx","newDy","atan2","getRadius","wrap","options","move","warp","canvasSize","newPos","bottom","offset","left","right","top","sizeValue","nextBounds","initialPosition","random"],"mappings":"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","sourcesContent":["import { Vector, calculateBounds, getDistances, isPointInside, randomInRange, } from \"tsparticles-engine\";\r\nexport class OutOutMode {\r\n    constructor(container) {\r\n        this.container = container;\r\n        this.modes = [\"out\"];\r\n    }\r\n    update(particle, direction, delta, outMode) {\r\n        if (!this.modes.includes(outMode)) {\r\n            return;\r\n        }\r\n        const container = this.container;\r\n        switch (particle.outType) {\r\n            case \"inside\": {\r\n                const { x: vx, y: vy } = particle.velocity;\r\n                const circVec = Vector.origin;\r\n                circVec.length = particle.moveCenter.radius;\r\n                circVec.angle = particle.velocity.angle + Math.PI;\r\n                circVec.addTo(Vector.create(particle.moveCenter));\r\n                const { dx, dy } = getDistances(particle.position, circVec);\r\n                if ((vx <= 0 && dx >= 0) || (vy <= 0 && dy >= 0) || (vx >= 0 && dx <= 0) || (vy >= 0 && dy <= 0)) {\r\n                    return;\r\n                }\r\n                particle.position.x = Math.floor(randomInRange({\r\n                    min: 0,\r\n                    max: container.canvas.size.width,\r\n                }));\r\n                particle.position.y = Math.floor(randomInRange({\r\n                    min: 0,\r\n                    max: container.canvas.size.height,\r\n                }));\r\n                const { dx: newDx, dy: newDy } = getDistances(particle.position, particle.moveCenter);\r\n                particle.direction = Math.atan2(-newDy, -newDx);\r\n                particle.velocity.angle = particle.direction;\r\n                break;\r\n            }\r\n            default: {\r\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\r\n                    return;\r\n                }\r\n                switch (particle.outType) {\r\n                    case \"outside\": {\r\n                        particle.position.x =\r\n                            Math.floor(randomInRange({\r\n                                min: -particle.moveCenter.radius,\r\n                                max: particle.moveCenter.radius,\r\n                            })) + particle.moveCenter.x;\r\n                        particle.position.y =\r\n                            Math.floor(randomInRange({\r\n                                min: -particle.moveCenter.radius,\r\n                                max: particle.moveCenter.radius,\r\n                            })) + particle.moveCenter.y;\r\n                        const { dx, dy } = getDistances(particle.position, particle.moveCenter);\r\n                        if (particle.moveCenter.radius) {\r\n                            particle.direction = Math.atan2(dy, dx);\r\n                            particle.velocity.angle = particle.direction;\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"normal\": {\r\n                        const wrap = particle.options.move.warp, canvasSize = container.canvas.size, newPos = {\r\n                            bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\r\n                            left: -particle.getRadius() - particle.offset.x,\r\n                            right: canvasSize.width + particle.getRadius() + particle.offset.x,\r\n                            top: -particle.getRadius() - particle.offset.y,\r\n                        }, sizeValue = particle.getRadius(), nextBounds = calculateBounds(particle.position, sizeValue);\r\n                        if (direction === \"right\" &&\r\n                            nextBounds.left > canvasSize.width + particle.offset.x) {\r\n                            particle.position.x = newPos.left;\r\n                            particle.initialPosition.x = particle.position.x;\r\n                            if (!wrap) {\r\n                                particle.position.y = Math.random() * canvasSize.height;\r\n                                particle.initialPosition.y = particle.position.y;\r\n                            }\r\n                        }\r\n                        else if (direction === \"left\" && nextBounds.right < -particle.offset.x) {\r\n                            particle.position.x = newPos.right;\r\n                            particle.initialPosition.x = particle.position.x;\r\n                            if (!wrap) {\r\n                                particle.position.y = Math.random() * canvasSize.height;\r\n                                particle.initialPosition.y = particle.position.y;\r\n                            }\r\n                        }\r\n                        if (direction === \"bottom\" &&\r\n                            nextBounds.top > canvasSize.height + particle.offset.y) {\r\n                            if (!wrap) {\r\n                                particle.position.x = Math.random() * canvasSize.width;\r\n                                particle.initialPosition.x = particle.position.x;\r\n                            }\r\n                            particle.position.y = newPos.top;\r\n                            particle.initialPosition.y = particle.position.y;\r\n                        }\r\n                        else if (direction === \"top\" && nextBounds.bottom < -particle.offset.y) {\r\n                            if (!wrap) {\r\n                                particle.position.x = Math.random() * canvasSize.width;\r\n                                particle.initialPosition.x = particle.position.x;\r\n                            }\r\n                            particle.position.y = newPos.bottom;\r\n                            particle.initialPosition.y = particle.position.y;\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}